using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Globalization;
using Microsoft.CSharp;
using System.CodeDom.Compiler;
using System.Net.Configuration;
using System.Runtime.InteropServices;

namespace SOM
{
	/// <summary>
	/// This class is responsible for converting the .xml file into a C# file
	/// </summary>
	public static class SOMCSHarpHandler
	{

		//========================================
		//Consts
		//========================================
		const string NAME = "StringOMatic";
		const string WITH_ERRORS = "WithErrors";

		//========================================
		//Properties
		//========================================
		static string _path;
		static string path
		{
			get
			{
				if (_path == null)
				{
					string[] folders = Directory.GetDirectories("Assets/", "StringOMatic*", SearchOption.AllDirectories);
					if (folders.Length == 0)
						throw new FileNotFoundException("StringOMatic folder could not be found");
					if (folders.Length > 1)
						throw new FileLoadException("More than one StringOMatic folder were found");
					_path = folders[0] + "/";
				}
				return _path;
			}
		}

		//========================================
		//Methods
		//========================================
		/// <summary>
		/// Generates a new C# file from the xml file. If the new file contains any compilation errors, it is created as a .txt file instead.
		/// </summary>
		///
		public static string GetUnityEngineDLLPath()
		{
			string unityInstallationPath = EditorApplication.applicationContentsPath;
			string unityEngineDLLPath = Path.Combine(unityInstallationPath, "Managed", "UnityEngine.dll");
			return unityEngineDLLPath;
		}

		public static string GetNetStandardDLLPath()
		{
			// Path to the netstandard assembly may vary depending on your .NET installation
			string netStandardPath = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "Facades", "netstandard.dll");
			return netStandardPath;
		}
		public static void Compile()
		{
			if (!SOMXmlHandler.DocumentExists())
				throw new XmlDocumentDoesNotExistException();

			StringBuilder file = new StringBuilder();

			//START WRITING
			file.AppendLine("/*=========================================================================");
			file.AppendLine("THIS DOCUMENT IS AUTOGENERATED AND SHOULD NOT BE MANUALLY EDITED OR DELETED!!!");
			file.AppendLine("===========================================================================*/");
			file.AppendLine();
			file.AppendLine("using System;");
			file.AppendLine("using UnityEngine;");
			file.AppendLine();
			file.AppendLine("public static class " + NAME);
			file.AppendLine("{");

			string[] modules = SOMXmlHandler.GetAllModules();
			int lastIndentation = 0;

			for (int i = 0; i < modules.Length; i++)
			{

				//Deal with opening indentation
				int indentation = modules[i].Split('.').Length;
				if (i != 0)
				{
					for (int j = 0; j <= lastIndentation - indentation; j++)
					{
						WriteIndentation(file, lastIndentation - j);
						file.AppendLine("}");
					}
				}

				//Each module is represented as a public static class
				WriteIndentation(file, indentation);
				string className = SOMUtils.NicifyModuleName(modules[i].Substring(modules[i].LastIndexOf(".") + 1));
				string[] parts = modules[i].Split('.');
				string moduleName = parts[0];
				string layerName = "";

				if (moduleName == "Mecanim")
				{
					int layersIndex = Array.IndexOf(parts, "layers");
					if (layersIndex != -1 && layersIndex < parts.Length - 1)
					{
						StringBuilder layerNameBuilder = new StringBuilder();

						for (int h = layersIndex + 1; h < parts.Length; h++)
						{
							if (parts[h] == "State Machines" || parts[h] == "states")
							{
								continue;
							}

							layerNameBuilder.Append(parts[h]);
							if (h < parts.Length - 1)
							{
								layerNameBuilder.Append(".");
							}
						}
						layerName = layerNameBuilder.ToString();
					}
				}


				file.AppendLine("public static class " + className);
				WriteIndentation(file, indentation);
				file.AppendLine("{");

				//Each constant, as a public string constant
				KeyValuePair<string, string>[] constants = SOMXmlHandler.GetAllConstants(modules[i]);



				for (int j = 0; j < constants.Length; j++)
				{
					WriteIndentation(file, indentation + 1);
					file.AppendLine("public const string " + constants[j].Key + " = \"" + constants[j].Value + "\";");

					if (moduleName == "Mecanim")
					{
						WriteIndentation(file, indentation + 1);

						string constantValue = constants[j].Value;
						if (layerName.EndsWith(constantValue))
						{
							layerName = layerName.Remove(layerName.Length - constantValue.Length);
						}

						string hashName = layerName + constantValue;

						file.AppendLine("public static int " + constants[j].Key + "Hash = Animator.StringToHash(\"" + hashName + "\");");

						// WriteIndentation(file, indentation + 1);

						// file.AppendLine("public const string " + constants[j].Key + "Module = \"" + modules[i] + "\";");


					}

				}

				lastIndentation = indentation;
			}
			//Deal with closing indentation
			for (int i = 0; i <= lastIndentation; i++)
			{
				WriteIndentation(file, lastIndentation - i);
				file.AppendLine("}");
			}
			//Check if the code can be compiled
			bool canBeCompiled = true;
			CSharpCodeProvider provider = new CSharpCodeProvider();
			CompilerParameters parameters = new CompilerParameters();
			parameters.ReferencedAssemblies.Add(GetUnityEngineDLLPath());
			parameters.ReferencedAssemblies.Add(GetNetStandardDLLPath());

			CompilerResults results = provider.CompileAssemblyFromSource(parameters, file.ToString());

			for (int i = 0; i < results.Errors.Count; i++)
			{
				if (!results.Errors[i].IsWarning)
				{
					canBeCompiled = false;
					break;
				}
			}

			string output = path + NAME;
			//If the code can't be compiled, create a new text file with the suffix WITH_ERRORS
			if (!canBeCompiled)
			{
				string log = "The newly created " + NAME + ".cs file contains the compilation errors listed below. " +
					"In order to maintain previous code stability and avoid trouble, the file has been renamed to " + NAME + WITH_ERRORS + ".txt. That'll teach it!\n\n";
				for (int i = 0; i < results.Errors.Count; i++)
					if (!results.Errors[i].IsWarning)
						log += "Line " + (results.Errors[i].Line + 1) + " --> error " + results.Errors[i].ErrorNumber + ": " + results.Errors[i].ErrorText + "\n";
				SOMUtils.LogError(log);
				output += WITH_ERRORS;
				output += ".txt";
			}
			else
			{
				output += ".cs";
				SOMUtils.Log("Compilation Successfull");
			}
			File.WriteAllText(output, file.ToString());
			AssetDatabase.ImportAsset(output.Substring(output.IndexOf("Assets/")));
		}
		static void WriteIndentation(StringBuilder file, int indentation)
		{
			StringBuilder value = new StringBuilder();
			for (int i = 0; i < indentation; i++)
				value.Append("\t");
			file.Append(value.ToString());
		}
	}
}