using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Microsoft.CSharp;
using System.CodeDom.Compiler;
using System.Linq;
using static SOM.LanguageConsts;



namespace SOM
{
	/// <summary>
	/// This class is responsible for generating a C# file
	/// </summary>
	public static class SOMCSHarpHandler
	{

		#region Consts
		//========================================
		//Consts
		//========================================
		// const string NAME = "StringOMatic";
		const string WITH_ERRORS = "WithErrors";
		const string COMPILATION_SUCCESSFUL = "Compilation Successful";

		private enum BraceState { Open, Close }

		#endregion


		#region Properties
		//Properties
		//========================================
		private static string OuterClassName => SOMPreferences.GetClassName();
		private static string CurrentModuleName { get; set; }
		private static string NamespaceName { get; set; }
		private static int RemainingOpenBraceCount { get; set; }
		private static int IndentationLevel { get; set; }
		private static bool WrapModuleNamespaces { get; set; }
		private static StringBuilder _StringBuilder { get; set; }
		private static Dictionary<string, object> FoundModules { get; set; }

		#endregion

		//========================================
		//Methods
		//========================================
		/// <summary>
		/// Generates a new C# file from the xml file. If the new file contains any compilation errors, it is created as a .txt file instead.
		/// </summary>
		///


		public static void Compile()
		{
			GenerateCS();
		}
		private static void Init()
		{

			_StringBuilder = new();
			FoundModules = new();

			IndentationLevel = 0;
			RemainingOpenBraceCount = 0;

			WrapModuleNamespaces = SOMPreferences.GetBoolFromPrefs(SOMManager.WRAP_NAMESPACES_KEY, false);

#if SOM_ADDRESSABLES

			SOMDataHandler.Singleton.ClearIResourceData();

#endif


		}
		private static void GenerateCS()
		{

			if (!SOMDataHandler.DatabaseExists())
				throw new DatabaseNotExistException();

			if (SOMDataHandler.ModuleCount == 0)
			{
				Debug.Log("No modules found");
				return;
			}

			Init();

			_StringBuilder.WriteHeaderMessage();
			_StringBuilder.WriteRootNamespace();
			_StringBuilder.WriteAllClasses();
			_StringBuilder.WriteEndRootNamespace();

			CompileCS(out bool compileSuccess, out CompilerResults results);

			LogResults(compileSuccess, OuterClassName, results);

			SaveFile(OuterClassName, compileSuccess);

		}
		private static bool HasRootNamespace()
		{
			return HasRootNamespace(out _);
		}
		private static bool HasRootNamespace(out string namespaceName)
		{
			namespaceName = SOMPreferences.GetNamespace();
			string niceNamespace = SOMUtils.NicifyModuleName(namespaceName);

			bool namespaceDefined = !String.IsNullOrEmpty(niceNamespace);

			return namespaceDefined;

		}
		private static bool CompileCS(out bool success, out CompilerResults results)
		{
			success = true;
			CSharpCodeProvider provider = new CSharpCodeProvider();
			CompilerParameters parameters = new CompilerParameters();

			results = provider.CompileAssemblyFromSource(parameters, _StringBuilder.ToString());

			for (int i = 0; i < results.Errors.Count; i++)
			{
				if (!results.Errors[i].IsWarning)
				{
					success = false;
					break;
				}
			}

			return success;
		}
		private static void LogResults(bool canBeCompiled, string outerclassName, CompilerResults results)
		{
			if (!canBeCompiled)
			{
				string log = $"The newly created {outerclassName}.cs file contains the compilation errors listed below." +
							"In order to maintain previous code stability and avoid trouble, the file has been renamed to " +
							$"{outerclassName + WITH_ERRORS + _dotTxt}. That'll teach it!{_newLine + _newLine}";


				for (int i = 0; i < results.Errors.Count; i++)
					if (!results.Errors[i].IsWarning)
						log += "Line " + (results.Errors[i].Line + 1) + " --> error " + results.Errors[i].ErrorNumber + ": " + results.Errors[i].ErrorText + _newLine;
				SOMUtils.LogError(log);
			}
			else
			{
				SOMUtils.Log($"{COMPILATION_SUCCESSFUL} - File saved to {GetSavePath(outerclassName) + _dotCS}");
			}
		}

		private static string GetSavePath(string className)
		{
			return SOMUtils.GetValidTargetDir(SOMPreferences.GetTargetDir()) + className;
		}
		private static void SaveFile(string className, bool compileSuccess)
		{
			string path = GetSavePath(className);

			path += compileSuccess ? _dotCS : WITH_ERRORS + _dotTxt;

			File.WriteAllText(path, _StringBuilder.ToString());
			AssetDatabase.ImportAsset(path/*.Substring(output.IndexOf("Assets/"))*/);

		}

		private static void WriteHeaderMessage(this StringBuilder sb)
		{
			if (!SOMPreferences.GetBoolFromPrefs(SOMManager.WRITE_COMMENT_KEY, true)) return;

			sb.AppendLine("/*=========================");
			sb.AppendLine("Generated by String-O-Matic");
			sb.AppendLine("=========================*/");
			sb.AppendLine();
		}
		private static void WriteNamespace(this StringBuilder sb, string namespaceName, int indent = 0)
		{
			sb.WriteIndentations(indent);
			sb.WriteLine($"{_namespace} {namespaceName}");
			sb.WriteIndentations(indent);
			sb.WriteBrace(BraceState.Open, indent);
		}
		private static void WriteRootNamespace(this StringBuilder sb)
		{

			string namespaceName = SOMManager.DEFAULT_NAMESPACE;

			HasRootNamespace(out namespaceName);

			NamespaceName = namespaceName;

			sb.WriteNamespace(namespaceName);

		}
		private static void WriteEndRootNamespace(this StringBuilder sb)
		{
			ResetIndentationLevel();
			sb.WriteEndNamespace();

		}
		private static void WriteEndNamespace(this StringBuilder sb, int indent = 0)
		{

			sb.WriteBrace(BraceState.Close, indent);
		}

		private static string GetClassString(string className)
		{
			return $"{_public} {_static} {_class} {className}";
		}
		private static string GetStructString(string structName)
		{
			return $"{_public} {_struct} {structName}";
		}

		private static readonly Dictionary<Type, string> validTypes = new()
		{
			{ typeof(System.String), "string" },
			{ typeof(System.Int32), "int" },
			{ typeof(System.Single), "float" },
			{ typeof(System.Double), "double" },
			{ typeof(System.Boolean), "bool" },
			{ typeof(System.DateTime), "DateTime" },
			{ typeof(System.Decimal), "decimal" },
			{ typeof(System.Char), "char" },
			{ typeof(System.Guid), "string" }
		};

		private static string TypeToString(object obj)
		{
			Type type = obj.GetType();
			// Check if the type has a mapping in the dictionary
			if (validTypes.ContainsKey(type))
			{
				return validTypes[type];
			}
			else
			{
				// Return the type name as is
				return "object";
			}
		}


		public static bool CanBeStatic(Type type)
		{
			if (type.IsClass || type.IsInterface || type == typeof(Guid))
			{
				return true; // Classes and interfaces can have static members
			}
			else if (type.IsEnum || type.IsValueType)
			{
				return false;
			}
			else if (typeof(Delegate).IsAssignableFrom(type)) // Delegates cannot be static
			{
				return false;
			}
			else
			{
				// Unknown type, assuming it can't be static
				return false;
			}
		}

		public static bool CanBeConst(Type type)
		{
			if ((type.IsEnum || IsPrimitiveType(type)) && type != typeof(Guid))
			{
				return true; // Enums and primitive types can be used for const variables
			}
			else
			{
				return false;
			}
		}

		private static bool IsPrimitiveType(Type type)
		{
			return type.IsPrimitive || type == typeof(decimal) || type == typeof(string);
		}

		private static object FormatConstantValue(object constValue)
		{
			if (!validTypes.ContainsKey(constValue.GetType()))
			{
				return "";
			}

			return constValue switch
			{
				string => $"\"{constValue}\"",
				float => constValue + "f",
				Guid => $"\"{constValue}\"",
				int => constValue,
				// Guid => $"new Guid(\"{constValue}\")",
				// #if SOM_ADDRESSABLES
				// 				ResourceLocationBase => "",
				// #endif
				_ => constValue,
			};
		}



		private static string GetConstString(string constName, object constValue)
		{

#if SOM_ADDRESSABLES
			SOMAddressablesHandler.ValidateAndStoreResLoc(pathBuilder, NamespaceName, constName, constValue);
#endif

			Type objType = constValue.GetType();

			object formattedValue = FormatConstantValue(constValue);

			StringBuilder sb = new();

			sb.Append($"{_public} ");

			if (CanBeConst(objType))
			{
				sb.Append($"{_const} ");
			}
			else if (CanBeStatic(objType))
			{
				sb.Append($"{_static} ");
			}

			string typeName = TypeToString(constValue);
			string equalsSymbol = !string.IsNullOrEmpty(formattedValue.ToString()) ? " = " : "";

			sb.Append($"{typeName} {constName}{equalsSymbol}{formattedValue};");

			return sb.ToString();
		}
		private static string GetConstString(string constName, string constValue)
		{
			return $"{_public} {_const} {_string} {constName} = \"{constValue}\";";
		}
		private static void WriteClass(this StringBuilder sb, string className, int indent = 0)
		{
			sb.WriteIndentations(indent);
			sb.WriteLine(GetClassString(className));
			sb.WriteIndentations(indent);
			sb.WriteBrace(BraceState.Open, indent);

		}
		private static void WriteStruct(this StringBuilder sb, string className, int indent = 0)
		{
			sb.WriteIndentations(indent);
			sb.WriteLine(GetStructString(className));
			sb.WriteIndentations(indent);
			sb.WriteBrace(BraceState.Open, indent);

		}

		private static void WriteEndClass(this StringBuilder sb, int indentLevel = 1)
		{
			sb.WriteIndentations(indentLevel);

			sb.WriteBrace(BraceState.Close, indentLevel);
		}


		public static string Repeat(string str, int count)
		{
			StringBuilder builder = new StringBuilder();
			for (int i = 0; i < count; i++)
			{
				builder.Append(str);
			}
			return builder.ToString();
		}



		private static StringBuilder pathBuilder = new();

		public static string GetAllConsts(Dictionary<string, object> dict, int indentLevel = 1,
	HashSet<Dictionary<string, object>> visited = null)
		{
			visited ??= new HashSet<Dictionary<string, object>>();
			StringBuilder result = new();
			string indent = Repeat(_indentStr, indentLevel);

			bool reachedConsts = false;

			bool isRoot = indentLevel == 1;

			foreach (var kvp in dict)
			{

				if (kvp.Value is Dictionary<string, object> nestedDict)
				{
					if (!visited.Contains(nestedDict))
					{

						if (isRoot)
						{
							if (WrapModuleNamespaces)
							{
								result.WriteNamespace(SOMUtils.NicifyModuleName(kvp.Key + "Module"), indentLevel);
								indentLevel++;
							}

							CurrentModuleName = kvp.Key;

							pathBuilder = new();
						}

						pathBuilder.Append(kvp.Key + _dotChar);

						// result.CheckForMecanimLayer(kvp.Value as string);

						visited.Add(nestedDict);
						// reachedStrings = nestedDict.Values.Any(val => val is string);
						reachedConsts = nestedDict.Values.Any(val => val is not Dictionary<string, object>);

						// var nectDict = kvp.Value as Dictionary<string, object>;
						// stringsNext = nectDict.First().Value is string;

						string staticsStr = isRoot ? _Statics : "";

						result.WriteClass(kvp.Key + staticsStr, indentLevel);


						result.Append(GetAllConsts(nestedDict, indentLevel + 1, visited));


						result.WriteEndClass(indentLevel);



						if (isRoot && WrapModuleNamespaces)
						{
							indentLevel--;
							result.WriteIndentations(indentLevel);
							result.WriteEndNamespace(indentLevel);
						}

					}
					else
					{
						// Dictionary already visited
					}
				}
				else // Reached strings
				{
					// result.WriteConstant(kvp.Key, kvp.Value as string, indentLevel);
					result.WriteConstant(kvp.Key, kvp.Value, indentLevel);

					// result.CheckAddMecanimConst(kvp.Key, kvp.Value as string, indentLevel);


				}
			}

			return result.ToString();
		}

		private static void WriteAllClasses(this StringBuilder sb)
		{
			SOMDictionary db = SOMDataHandler.GetRootData();

			sb.Append(GetAllConsts(db));
		}

		private static void WriteConstant(this StringBuilder sb, string constName, string constValue, int indentLevel)
		{
			sb.WriteIndentations(indentLevel);
			sb.WriteLine(GetConstString(constName, constValue));
		}
		private static void WriteConstant(this StringBuilder sb, string constName, object constValue, int indentLevel)
		{
			sb.WriteIndentations(indentLevel);
			sb.WriteLine(GetConstString(constName, constValue));
		}

		static void WriteLine(this StringBuilder sb, string content = "")
		{
			sb.AppendLine(content);
		}

		static void WriteBlockComment(this StringBuilder sb, string content = "")
		{
			sb.AppendLine(_blockQuoteOpen + content + _blockQuoteClose);
		}
		static void WriteLineComment(this StringBuilder sb, string content = "", int indent = 1)
		{
			sb.WriteIndentations(indent);
			sb.AppendLine(_doublefslash + content);
		}
		public static void InsertLineComment(this StringBuilder sb, string content = "", int indent = 1)
		{
			if (sb.Length > _newLine.Length && sb.ToString(sb.Length - _newLine.Length, _newLine.Length) == _newLine)
			{
				// If the last characters are a newline, remove them
				sb.Remove(sb.Length - _newLine.Length, _newLine.Length);

			}

			int position = sb.Length;
			sb.Insert(position, _indentStr + _doublefslash + content);
			// Append newline after the comment
			sb.Append(_newLine);
		}
		static void WriteBrace(this StringBuilder sb, BraceState braceState, int indent = 1)
		{
			if (braceState == BraceState.Open)
			{
				sb.Append(_openBrace);
				IncreaseBraceCount(1);
			}
			else
			{
				sb.Append(_closeBrace);
				DecreaseBraceCount(1);
			}

			sb.AppendLine();
		}

		static void IncreaseBraceCount(int amount = 1)
		{
			RemainingOpenBraceCount += amount;
		}
		static void DecreaseBraceCount(int amount = 1)
		{
			if (amount <= 0 || RemainingOpenBraceCount == 0) return;
			RemainingOpenBraceCount -= amount;
		}

		static string GetIndentations(int indentLevel)
		{
			StringBuilder builder = new StringBuilder();
			for (int i = 0; i < indentLevel; i++)
			{
				builder.Append(_indentStr);
			}
			return builder.ToString();
		}
		static void WriteIndentations(this StringBuilder sb, int indentations = 0)
		{
			sb.Append(_indentChar, indentations);
		}

		static void RemoveIndentations()
		{
			if (_StringBuilder.Length > 0 && _StringBuilder[_StringBuilder.Length - 1] == '\t')
			{
				_StringBuilder.Remove(_StringBuilder.Length - 1, 1);
				DecreaseIndentationLevel();
			}
		}
		static void IncreaseIndentationLevel(int indentations = 1)
		{
			IndentationLevel += indentations;
		}
		static void DecreaseIndentationLevel(int indentations = 1)
		{
			if (indentations <= 0 || IndentationLevel == 0) return;
			IndentationLevel -= Math.Max(0, indentations);
		}
		static void SetIndentationLevel(int indentations = 1)
		{
			IndentationLevel = Math.Max(0, indentations);
		}
		static void ResetIndentationLevel()
		{
			IndentationLevel = 0;
		}
		public static string GetMecanimLayername(string[] parts)
		{
			string layerName = "";
			int layersIndex = Array.IndexOf(parts, SOMMecanimModule.layers);

			if (layersIndex != -1 && layersIndex < parts.Length - 1)
			{
				StringBuilder layerNameBuilder = new();

				for (int h = layersIndex + 1; h < parts.Length; h++)
				{
					if (parts[h] == SOMMecanimModule.StateMachines || parts[h] == SOMMecanimModule.states)
					{
						continue;
					}

					layerNameBuilder.Append(parts[h]);
					if (h < parts.Length - 1)
					{
						layerNameBuilder.Append(_dotStr);
					}
				}
				layerName = layerNameBuilder.ToString();
			}

			return layerName;
		}

	}
}